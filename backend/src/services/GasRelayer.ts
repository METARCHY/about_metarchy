import { ethers } from 'ethers';
import * as fs from 'fs';
import * as path from 'path';

// Load the ABI generated by Hardhat
const ledgerPath = path.resolve(process.cwd(), 'src/abis/MatchLedger.json');
const ledgerJson = JSON.parse(fs.readFileSync(ledgerPath, 'utf8'));

// The deployed contract address (TODO: Set this from env after deployment)
const CONTRACT_ADDRESS = process.env.MATCH_LEDGER_ADDRESS || '0x0000000000000000000000000000000000000000';

class GasRelayer {
    private provider: ethers.JsonRpcProvider;
    private wallet: any;
    private contract: ethers.Contract;
    private isEnabled: boolean = false;

    constructor() {
        // Avalanche Fuji RPC
        const rpcUrl = process.env.AVALANCHE_RPC_URL || 'https://api.avax-test.network/ext/bc/C/rpc';
        this.provider = new ethers.JsonRpcProvider(rpcUrl);

        const privateKey = process.env.RELAYER_PRIVATE_KEY;
        if (privateKey) {
            this.wallet = new ethers.Wallet(privateKey, this.provider);
            this.contract = new ethers.Contract(CONTRACT_ADDRESS, ledgerJson.abi, this.wallet);
            this.isEnabled = true;
            console.log(`[GasRelayer] Initialized with wallet: ${this.wallet.address}`);
        } else {
            console.warn('[GasRelayer] Disabled: RELAYER_PRIVATE_KEY is missing in backend env.');
            // Initialize dummy contract for local dev
            this.wallet = ethers.Wallet.createRandom(this.provider);
            this.contract = new ethers.Contract(CONTRACT_ADDRESS, ledgerJson.abi, this.wallet);
        }
    }

    /**
     * Submits the cryptographic hash representing both players' actions to the Avalanche Ledger.
     */
    public async commitTurnHash(matchId: string, turnNumber: number, p1Hash: string, p2Hash: string): Promise<boolean> {
        if (!this.isEnabled) {
            console.log(`[GasRelayer] DEV MODE: Would have submitted turn ${turnNumber} for match ${matchId} to Avalanche.`);
            return true;
        }

        try {
            console.log(`[GasRelayer] Constructing unified hash for Match ${matchId}, Turn ${turnNumber}...`);

            // Mathematically combine both hashes
            const unifiedHash = ethers.keccak256(
                ethers.AbiCoder.defaultAbiCoder().encode(['string', 'string'], [p1Hash, p2Hash])
            );

            console.log(`[GasRelayer] Submitting hash to MatchLedger contract: ${unifiedHash}`);
            const tx = await this.contract.commitTurn(matchId, turnNumber, unifiedHash);

            console.log(`[GasRelayer] Transaction sent: ${tx.hash}. Waiting for confirmation...`);
            await tx.wait(1); // Wait for 1 block

            console.log(`[GasRelayer] Turn ${turnNumber} successfully permanently anchored to Avalanche.`);
            return true;
        } catch (error) {
            console.error(`[GasRelayer] Failed to submit hash to blockchain:`, error);
            return false;
        }
    }
}

// Export a singleton instance
export const globalGasRelayer = new GasRelayer();
